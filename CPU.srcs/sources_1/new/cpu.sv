`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 09/30/2024 11:43:08 AM
// Design Name: 
// Module Name: cpu
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module cpu(
    input rst_n, clk,
    output logic [31:0] imem_addr,
    input [31:0] imem_insn,
    output logic [31:0] dmem_addr,
    inout logic [31:0] dmem_data,
    output logic dmem_wen, // 1 = W, 0 = R
    output logic [3:0] byte_en, // each bit represents a byte that should be written to or read from
    output [31:0] reg_write_data,
    output [4:0] rd_out
);

// PIPELINE REG
        
    // ********************************
    // *       Fetch -> Decode         *
    // ********************************
    logic if_id_wen = 1;
    logic [31:0] if_id_instruction;
    
    // ********************************
    // *       Decode -> Execute      *
    // ********************************
    
    logic id_ex_wen = 1;
    logic id_ex_branch, id_ex_mem_read, id_ex_mem_to_reg;
    // ALUSrc -> is_operand_imm
    logic id_ex_mem_write, id_ex_is_operand_imm;
    logic id_ex_reg_write;
    
    logic [31:0] id_ex_signed_imm, id_ex_reg_read_data_one, id_ex_reg_read_data_two;
    logic [3:0] id_ex_alu_op;
    logic [4:0] id_ex_rs1, id_ex_rs2, id_ex_rd;
    
    // ********************************
    // *   Execute -> Memory Access   *
    // ********************************
    logic ex_mem_wen = 1;
    logic [4:0] ex_mem_rd;
    logic ex_mem_mem_to_reg;
    logic ex_mem_branch, ex_mem_mem_read, ex_mem_mem_write;
    logic ex_mem_reg_write;
    logic [31:0] ex_mem_alu_result, ex_mem_reg_read_data_two;
    logic [3:0] ex_mem_buf_size;
    
    
    
    // ********************************
    // *   Memory Access -> Writeback *
    // ********************************
    logic mem_wb_write = 1;
    logic [4:0] mem_wb_rd;
    logic mem_wb_reg_write, mem_wb_mem_to_reg;
    logic [31:0] mem_wb_read_data, mem_wb_alu_result;
    
    // ********************************
    // *           Writeback          *
    // ********************************
    logic [31:0] wb_reg_write_data;
// END PIPELINE REG

// Program Counter Register
// TODO: Propagate PC state to MEM stage for jumping.
logic [31:0] new_pc, pc = 0;
logic pc_wen = 1;
//import pipeline_registers_pkg::*;

// ********************************
// *            Fetch             *
// ********************************
logic [31:0] f_instruction;

fetch f(rst_n, 
    pc, imem_insn, 
    new_pc, imem_addr, f_instruction);

always @ (posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        pc <= 32'b0; // Reset PC to 0
    end else if (pc_wen) begin
        pc <= new_pc; // Update PC to the new PC generated by fetch
    end
end

always @ (posedge clk) begin
    // TODO: reset and write enable
    if (if_id_wen) if_id_instruction <= f_instruction;
end

// ********************************
// *            Decode            *
// ********************************
logic [4:0] d_rs1, d_rs2, d_rd;
// TODO: Why does it say to extend imm up to 64 bits for a 32 bit CPU?
logic [31:0] d_signed_imm, d_reg_read_data_one, d_reg_read_data_two;
logic d_branch, d_mem_read, d_mem_write, 
    d_mem_to_reg, d_is_operand_imm, d_reg_write;
logic [3:0] d_alu_op;

// Handle stalls
stall_handler sh(id_ex_mem_read, id_ex_mem_write,
    d_rs1, d_rs2, id_ex_rd, d_rd, 
    pc_wen, if_id_wen, id_ex_wen);

// Ensure that mem_read and/or mem_write are ONLY set when theres a valid memory address.
decode d(if_id_instruction,
         d_rs1, d_rs2, d_rd, 
         d_signed_imm, 
         d_branch, d_mem_read, d_mem_to_reg, d_mem_write, d_is_operand_imm, d_reg_write, 
         d_alu_op);

always @ (posedge clk) begin
    if (id_ex_wen) begin
        // Control Propagation
        id_ex_branch <= d_branch;
        id_ex_mem_read <= d_mem_read;
        id_ex_mem_write <= d_mem_write;
        id_ex_mem_to_reg <= d_mem_to_reg;
        id_ex_is_operand_imm <= d_is_operand_imm;
        id_ex_reg_write <= d_reg_write;
        id_ex_alu_op <= d_alu_op;
    
        // Data Propagation
        id_ex_rs1 <= d_rs1;
        id_ex_rs2 <= d_rs2;
        id_ex_rd <= d_rd;
        id_ex_signed_imm <= d_signed_imm;
    end else begin
        // Control Propagation
        id_ex_branch <= 0;
        id_ex_mem_read <= 0;
        id_ex_mem_write <= 0;
        id_ex_mem_to_reg <= 0;
        id_ex_is_operand_imm <= 0;
        id_ex_reg_write <= 0;
        id_ex_alu_op <= 'b1111; // nop for alu
    
        // Data Propagation
        id_ex_rs1 <= 0;
        id_ex_rs2 <= 0;
        id_ex_rd <= 0;
        id_ex_signed_imm <= 0;
    end
end



// ********************************
// *            Execute           *
// ********************************

logic [1:0] forward_a, forward_b;
logic [31:0] x_alu_second_src;
logic [31:0] x_alu_first_src;
logic [31:0] x_reg_src;
logic [31:0] x_alu_result;
logic [3:0] x_alu_op;
logic [31:0] x_reg_read_data_two;

forwarding fwd(id_ex_rs1, id_ex_rs2, ex_mem_rd, mem_wb_rd, forward_a, forward_b);

// Forwarding muxes
always_comb begin
    // First source mux
    case (forward_a)
        2'b10   : x_alu_first_src = ex_mem_alu_result;
        2'b01   : x_alu_first_src = wb_reg_write_data;
        default : x_alu_first_src = id_ex_reg_read_data_one;
    endcase

    // Second source mux
    case (forward_b)
        2'b10   : x_reg_src = ex_mem_alu_result;
        2'b01   : x_reg_src = wb_reg_write_data;
        default : x_reg_src = id_ex_reg_read_data_two;
    endcase
end

assign x_alu_second_src = id_ex_is_operand_imm ? id_ex_signed_imm : x_reg_src;
assign x_alu_op = id_ex_mem_read || id_ex_mem_write ? 0 : id_ex_alu_op;

alu a(x_alu_first_src, x_alu_second_src,
      x_alu_op,
      x_alu_result);


always_comb begin
    if (id_ex_mem_write) begin
        case (forward_b)
            2: x_reg_read_data_two = ex_mem_alu_result;
            1: x_reg_read_data_two = wb_reg_write_data;
            default: x_reg_read_data_two = id_ex_reg_read_data_two;
        endcase
    end
end
//assign x_reg_read_data_two = (id_ex_mem_write && forward_b == 2) ? ex_mem_alu_result : id_ex_reg_read_data_two;
always @ (posedge clk) begin
    // Control Propagation
    ex_mem_branch <= id_ex_branch;
    ex_mem_mem_read <= id_ex_mem_read;
    ex_mem_mem_write <= id_ex_mem_write;
    ex_mem_mem_to_reg <= id_ex_mem_to_reg;
    ex_mem_reg_write <= id_ex_reg_write;

    // Data Propagation
    ex_mem_alu_result <= x_alu_result;
    ex_mem_reg_read_data_two <= x_reg_read_data_two;
    ex_mem_rd <= id_ex_rd;
    ex_mem_buf_size <= id_ex_alu_op;
end

// ********************************
// *        Memory Access         *
// ********************************

logic [31:0] m_read_data;
mem_access m(
    ex_mem_mem_read, ex_mem_mem_write,
    ex_mem_buf_size, 
    ex_mem_alu_result, ex_mem_reg_read_data_two, 
    dmem_data, 
    dmem_wen, 
    byte_en,
    dmem_addr, m_read_data
);

always @ (posedge clk) begin
    // Control Propagation
    mem_wb_reg_write <= ex_mem_reg_write;
    mem_wb_mem_to_reg <= ex_mem_mem_to_reg;

    // Data Propagation
    mem_wb_read_data <= m_read_data;
    mem_wb_alu_result <= ex_mem_alu_result;
    mem_wb_rd <= ex_mem_rd;
end

// ********************************
// *           Writeback          *
// ********************************

write_back wb(mem_wb_read_data, mem_wb_alu_result, mem_wb_mem_to_reg, wb_reg_write_data);
assign reg_write_data = wb_reg_write_data;
assign rd_out = mem_wb_rd;

// ********************************
// *           Registers          *
// ********************************

// TODO: Register source data should be queried in decode, data is then pipelined to
// ID/EX
registers rf(clk, mem_wb_reg_write, 
             id_ex_rs1, id_ex_rs2, mem_wb_rd, 
             wb_reg_write_data, 
             id_ex_reg_read_data_one, 
             id_ex_reg_read_data_two);

endmodule

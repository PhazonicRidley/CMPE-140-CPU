`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 09/30/2024 11:43:08 AM
// Design Name: 
// Module Name: cpu
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module cpu(
    input rst_n, clk,
    output logic [31:0] imem_addr,
    input [31:0] imem_insn,
    output logic [31:0] dmem_addr,
    inout logic [31:0] dmem_data,
    output logic dmem_wen, // 1 = W, 0 = R
    output [31:0] reg_write_data,
    output [4:0] rd_out
);

// Program Counter Register
// TODO: Propagate PC state to MEM stage for jumping.
logic [31:0] new_pc, pc = 0;
logic pc_write = 1;
import pipeline_registers_pkg::*;

// ********************************
// *            Fetch             *
// ********************************
logic [31:0] f_instruction;

fetch f(pc, imem_insn, new_pc, imem_addr, f_instruction);

always @ (posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        pc <= 32'b0; // Reset PC to 0
    end else if (pc_write) begin
        pc <= new_pc; // Update PC to the new PC generated by fetch
    end
end

always @ (posedge clk) begin
    // TODO: reset and write enable
    if (if_id_write) if_id_instruction <= f_instruction;
end

// ********************************
// *            Decode            *
// ********************************
logic [4:0] d_rs1, d_rs2, d_rd;
// TODO: Why does it say to extend imm up to 64 bits for a 32 bit CPU?
logic [31:0] d_signed_imm, d_reg_read_data_one, d_reg_read_data_two;
logic d_branch, d_mem_read, d_mem_write, 
    d_mem_to_reg, d_is_operand_imm, d_reg_write;
logic [3:0] d_alu_op;

// Handle stalls
stall_handler sh(id_ex_mem_read, d_rs1, d_rs2, id_ex_rd, pc_write, d_write, id_ex_write);

// Ensure that mem_read and/or mem_write are ONLY set when theres a valid memory address.
decode d(if_id_instruction, d_rs1, d_rs2, d_rd, 
         d_signed_imm, d_branch, d_mem_read, 
         d_mem_to_reg, d_mem_write, 
         d_is_operand_imm, d_reg_write, d_alu_op);

always @ (posedge clk) begin
    if (id_ex_write) begin
        // Control Propagation
        id_ex_branch <= d_branch;
        id_ex_mem_read <= d_mem_read;
        id_ex_mem_write <= d_mem_write;
        id_ex_mem_to_reg <= d_mem_to_reg;
        id_ex_mem_write <= d_mem_write;
        id_ex_is_operand_imm <= d_is_operand_imm;
        id_ex_reg_write <= d_reg_write;
        id_ex_alu_op <= d_alu_op;
    
        // Data Propagation
        id_ex_rs1 <= d_rs1;
        id_ex_rs2 <= d_rs2;
        id_ex_rd <= d_rd;
        id_ex_signed_imm <= d_signed_imm;
    end else begin
        // Control Propagation
        id_ex_branch <= 0;
        id_ex_mem_read <= 0;
        id_ex_mem_write <= 0;
        id_ex_mem_to_reg <= 0;
        id_ex_mem_write <= 0;
        id_ex_is_operand_imm <= 0;
        id_ex_reg_write <= 0;
        id_ex_alu_op <= 0;
    
        // Data Propagation
        id_ex_rs1 <= 0;
        id_ex_rs2 <= 0;
        id_ex_rd <= 0;
        id_ex_signed_imm <= 0;
    end
end



// ********************************
// *            Execute           *
// ********************************

logic [1:0] forward_a, forward_b;
logic [31:0] x_alu_second_src;
logic [31:0] x_alu_first_src;
logic [31:0] x_reg_src;
logic [31:0] x_alu_result;

forwarding fwd(id_ex_rs1, id_ex_rs2, ex_mem_rd, mem_wb_rd, forward_a, forward_b);

// Forwarding muxes
always_comb begin
    // First source mux
    case (forward_a)
        2'b10   : x_alu_first_src = ex_mem_alu_result;
        2'b01   : x_alu_first_src = wb_reg_write_data;
        default : x_alu_first_src = id_ex_reg_read_data_one;
    endcase

    // Second source mux
    case (forward_b)
        2'b10   : x_reg_src = ex_mem_alu_result;
        2'b01   : x_reg_src = wb_reg_write_data;
        default : x_reg_src = id_ex_reg_read_data_two;
    endcase
end

assign x_alu_second_src = id_ex_is_operand_imm ? id_ex_signed_imm : x_reg_src;

alu a(x_alu_first_src, x_alu_second_src,
      id_ex_alu_op, x_alu_result);

always @ (posedge clk) begin
    // Control Propagation
    ex_mem_branch <= id_ex_branch;
    ex_mem_mem_read <= id_ex_mem_read;
    ex_mem_mem_write <= id_ex_mem_write;
    ex_mem_mem_to_reg <= id_ex_mem_to_reg;
    ex_mem_reg_write <= id_ex_reg_write;

    // Data Propagation
    ex_mem_alu_result <= x_alu_result;
    ex_mem_reg_read_data_two <= id_ex_reg_read_data_two;
    ex_mem_rd <= id_ex_rd;
end

// ********************************
// *        Memory Access         *
// ********************************

logic [31:0] m_read_data;

mem_access m(ex_mem_mem_read, 
             ex_mem_mem_write, 
             ex_mem_alu_result, ex_mem_reg_read_data_two,
             // dmem_data,
             m_read_data,
             dmem_addr, 
             dmem_wen);

always @ (posedge clk) begin
    // Control Propagation
    mem_wb_reg_write <= ex_mem_reg_write;
    mem_wb_mem_to_reg <= ex_mem_mem_to_reg;

    // Data Propagation
    mem_wb_read_data <= m_read_data;
    mem_wb_alu_result <= ex_mem_alu_result;
    mem_wb_rd <= ex_mem_rd;
end

// ********************************
// *           Writeback          *
// ********************************

write_back wb(mem_wb_read_data, mem_wb_alu_result, mem_wb_mem_to_reg, wb_reg_write_data);
assign reg_write_data = wb_reg_write_data;
assign rd_out = mem_wb_rd;

// ********************************
// *           Registers          *
// ********************************

// TODO: Register source data should be queried in decode, data is then pipelined to
// ID/EX
registers rf(clk, mem_wb_reg_write, 
             id_ex_rs1, id_ex_rs2, mem_wb_rd, 
             wb_reg_write_data, 
             id_ex_reg_read_data_one, 
             id_ex_reg_read_data_two);

endmodule
